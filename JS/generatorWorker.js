// The Web Worker imports the common code
importScripts('./sudokuCommon.js');

// The Web Worker is assigned a message handler.

self.addEventListener("message", async (event) => {
    let request = JSON.parse(event.data);
    if (request.name == 'getNewPuzzle') {
        try {
            // If the message is "getNewPuzzle", the Web Worker takes a new puzzle
            // from the web worker internal store
            sudoApp.mySolver.setCurrentPuzzle(PuzzleRecord.nullPuzzleRecord())
            //let puzzleRecord = sudoApp.mySolver.generatePuzzle(request.value);

            let puzzleRecord = await sudoApp.myNewPuzzleStore.getPuzzle(request.value);


            let response = {
                name: 'generated',
                value: puzzleRecord
            }
            let str_response = JSON.stringify(response);
            // The serialized puzzle is sent as a message to Main
            // respond on the received port
            event.ports[0].postMessage({ result: str_response });
            event.ports[0].close();
        } catch (e) {
            event.ports[0].postMessage({ error: e });
        }
    } else if (request.name == 'fillPuzzleStore') {
        try {
            // If the message is "fillPuzzleStore", the Web Worker 
            // creates at least one new puzzle in the store
            let isFilled = await sudoApp.myNewPuzzleStore.fill();
            let response = {
                name: 'fillStepExecuted',
                value: isFilled
            }
            let str_response = JSON.stringify(response);
            // The serialized puzzle is sent as a message to Main
            // respond on the received port
            event.ports[0].postMessage({ result: str_response });
            event.ports[0].close();
        } catch (e) {
            event.ports[0].postMessage({ error: e });
        }
    }
}, false);


class SudokuGeneratorApp {
    constructor() {
        // ==============================================================
        // Components of the app
        // ==============================================================
        // 1. The solver component
        this.mySolver = new SudokuSolver(this);
        // 2. The synchronous search step loop.
        this.mySyncRunner = new SynchronousRunner();
        // 3. The PuzzleStore, which is filled with  puzzles 
        // for each difficulty level when the app is launched. 
        // When a new puzzle is requested, it is taken from the store 
        // and the store is replenished in the background.
        this.myNewPuzzleStore = new NewPuzzleStore();
    }

    init() {
        this.mySolver.myGrid.init();
        this.mySolver.setActualEvalType('strict-plus');
        this.mySolver.setPlayType('automated-solving');
        this.myNewPuzzleStore.init();
    }

    breakpointPassed(bp) {
        this.mySyncRunner.breakpointPassed(bp);
    }

    getMySolver() {
        return this.mySolver;
    }
}

class NewPuzzleStore {
    // This is a store of new puzzles. For each difficulty it stores
    // 2 puzzles in advance, such that a request for a new puzzle
    // can be served without delay. 
    // During the initiation of the solver the puzzles in the store 
    // are generated by web-workers in the background.
    constructor() {
        this.verySimplePuzzles = [];
        this.simplePuzzles = [];
        this.mediumPuzzles = [];
        this.heavyPuzzles = [];
        this.veryHeavyPuzzles = [];
        this.extremeHeavyPuzzles = [];
        this.isLoading = false;
    }
    init() {
        this.fill();
    }

    simplifyPuzzleByNrOfCells(nr, puzzleRecord) {
        let randomCellOrder = Randomizer.getRandomNumbers(81, 0, 81);
        let nrSolved = 0;
        for (let i = 0; i < 81; i++) {
            let k = randomCellOrder[i];
            if (nrSolved < nr && puzzleRecord.puzzle[k].cellValue == '0') {
                puzzleRecord.puzzle[k].cellValue =
                    puzzleRecord.preRunRecord.solvedPuzzle[k].cellValue;
                puzzleRecord.puzzle[k].cellPhase = 'define';
                puzzleRecord.preRunRecord.solvedPuzzle[k].cellPhase = 'define';
                nrSolved++;
            }
        }
        puzzleRecord.statusGiven = puzzleRecord.statusGiven + nr;
        puzzleRecord.preRunRecord.level = 'Sehr leicht';
        puzzleRecord.preRunRecord.backTracks = 0;
        return puzzleRecord;
    }

    deleteOnePuzzleCell(puzzleRecord) {
        let extremePZ = JSON.parse(JSON.stringify(puzzleRecord));
        let randomCellOrder = Randomizer.getRandomNumbers(81, 0, 81);
        for (let i = 0; i < 81; i++) {
            let k = randomCellOrder[i];
            if (extremePZ.puzzle[k].cellValue !== '0') {
                extremePZ.puzzle[k].cellValue = '0';
                // let preRec = sudoApp.mySolver.calculatedPreRunRecord(extremePZ.puzzle);
                let preRec = sudoApp.mySolver.computePuzzlePreRunData(extremePZ.puzzle);
                if (preRec.level == 'Extrem schwer') {
                    extremePZ.preRunRecord.level = 'Extrem schwer';
                    extremePZ.preRunRecord.backTracks = '-';
                    return extremePZ;
                }
            }
        }
    }
    isFilled() {
        return (
            this.extremeHeavyPuzzles.length > 0
            && this.verySimplePuzzles.length > 0
            && this.simplePuzzles.length > 2
            && this.mediumPuzzles.length > 0
            && this.heavyPuzzles.length > 0
            && this.veryHeavyPuzzles.length > 0
        );
    }

    fill() {
        let puzzleRecord = sudoApp.mySolver.generatePuzzle();
        this.pushPuzzle(puzzleRecord);
        if (this.simplePuzzles.length > 1) {
            this.fillVerySimple();
            this.fillExtremeHeavy();
        }
        return this.isFilled();
    }

    fillVerySimple() {
        if (this.verySimplePuzzles.length < 1) {
            let simplePuzzleRecord = this.simplePuzzles.pop();
            // A simple puzzle can be made into a very simple puzzle 
            // by adding solved cells. The number of 7 added cells is arbitrary, but pragmatic.
            let verySimplePuzzleRecord
                = this.simplifyPuzzleByNrOfCells(7, simplePuzzleRecord);

            this.verySimplePuzzles.push(verySimplePuzzleRecord);
            this.pushed = true;
            console.log('');
            console.log('-------> push: Sehr leicht: #' + this.verySimplePuzzles.length);
            this.logPuzzleStore('');
        } else {
            console.log('push:Sehr leicht: verfallen');
        }
    }

    fillExtremeHeavy() {
        if (this.extremeHeavyPuzzles.length < 1) {
            let simplePuzzleRecord = this.simplePuzzles.pop();
            // A simple puzzle can be made to extremeVeryHeavy by deleting one given
            let verySimplePuzzleRecord = this.deleteOnePuzzleCell(simplePuzzleRecord);
            this.extremeHeavyPuzzles.push(verySimplePuzzleRecord);
            this.pushed = true;
            console.log('');
            console.log('-------> push: Extrem schwer: #' + this.extremeHeavyPuzzles.length);
            this.logPuzzleStore('');
        } else {
            console.log('push: Extrem schwer: verfallen');
        }
    }


    logPuzzleStore(head) {
        console.log('=========== ' + head + ' =============');
        console.log('verySimplePuzzles__: ' + this.verySimplePuzzles.length);
        console.log('simplePuzzles______: ' + this.simplePuzzles.length);
        console.log('mediumPuzzles______: ' + this.mediumPuzzles.length);
        console.log('heavyPuzzles_______: ' + this.heavyPuzzles.length);
        console.log('veryHeavyPuzzles___: ' + this.veryHeavyPuzzles.length);
        console.log('extremeHeavyPuzzles: ' + this.extremeHeavyPuzzles.length);
    }

    pushPuzzle(puzzleRecord) {
        switch (puzzleRecord.preRunRecord.level) {
            case 'Unl√∂sbar':
            case 'Keine Angabe':
            case 'Sehr leicht':
            case 'Extrem schwer': {
                // console.log('Unbrauchbare generierte Puzzles: ' + puzzleRecord.preRunRecord.level); break;
                break;
            }
            case 'Leicht': {
                if (this.simplePuzzles.length < 3) {
                    this.simplePuzzles.push(puzzleRecord);
                    console.log('-------> push: Leicht: #' + this.simplePuzzles.length);
                    this.logPuzzleStore('');
                } else {
                    console.log('push: Leicht: verfallen');
                };
                break;
            }
            case 'Mittel': {
                if (this.mediumPuzzles.length < 1) {
                    this.mediumPuzzles.push(puzzleRecord);
                    console.log('-------> push: Mittel: #' + this.mediumPuzzles.length);
                    this.logPuzzleStore('');
                } else {
                    console.log('push: Mittel: verfallen');
                };
                break;
            }
            case 'Schwer': {
                if (this.heavyPuzzles.length < 1) {
                    this.heavyPuzzles.push(puzzleRecord);
                    console.log('-------> push: Schwer: #' + this.heavyPuzzles.length)
                    this.logPuzzleStore('');
                } else {
                    console.log('push: Schwer: verfallen');
                };
                break;
            }
            case 'Sehr schwer': {
                if (this.veryHeavyPuzzles.length < 1) {
                    this.veryHeavyPuzzles.push(puzzleRecord);
                    console.log('');
                    console.log('-------> push: Sehr schwer: #' + this.veryHeavyPuzzles.length)
                    this.logPuzzleStore('');
                } else {
                    console.log('push: Sehr schwer: verfallen');
                };
                break;
            }
            default: {
                throw new Error('Unexpected difficulty: ' + puzzleRecord.preRunRecord.level);
            }
        }
    }

    async popFrom(puzzles) {
        let myPzGen = new Promise(myResolve => {
            if (puzzles.length > 0) {
                let pr = puzzles.pop();
                myResolve(pr);
            }
        });
        return await myPzGen;
    }

    async getPuzzle(difficulty) {
        let puzzleRecord = undefined;
        switch (difficulty) {
            case 'Sehr leicht': {
                puzzleRecord = await this.popFrom(sudoApp.myNewPuzzleStore.verySimplePuzzles)
                this.logPuzzleStore('-----> pop Sehr leicht')
                break;
            }
            case 'Leicht': {
                puzzleRecord = await this.popFrom(sudoApp.myNewPuzzleStore.simplePuzzles)
                this.logPuzzleStore('-----> pop Leicht')
                break;
            }
            case 'Mittel': {
                puzzleRecord = await this.popFrom(sudoApp.myNewPuzzleStore.mediumPuzzles)
                this.logPuzzleStore('-----> pop Mittel')
                break;
            }
            case 'Schwer': {
                puzzleRecord = await this.popFrom(sudoApp.myNewPuzzleStore.heavyPuzzles)
                this.logPuzzleStore(' -----> pop Schwer')
                break;
            }
            case 'Sehr schwer': {
                puzzleRecord = await this.popFrom(sudoApp.myNewPuzzleStore.veryHeavyPuzzles)
                this.logPuzzleStore('-----> pop Sehr schwer')
                break;
            }
            case 'Extrem schwer': {
                puzzleRecord = await this.popFrom(sudoApp.myNewPuzzleStore.extremeHeavyPuzzles)
                this.logPuzzleStore('-----> pop Extrem schwer')
                break;
            }
            default: {
                throw new Error('Unexpected difficulty: ' + difficulty);
            }
        }
        this.fill();
        return puzzleRecord;
    }
}

function startGeneratorApp() {
    //A worker app is assigned to the variable "sudoApp".
    sudoApp = new SudokuGeneratorApp();
    sudoApp.init();
}
// Launch and initialize the worker app
startGeneratorApp();
